\chapter{The CHERI ABIs}
\label{chp:abis}

The CHERI compiler supports two ABIs, an extended version of the MIPS n64 ABI and the \sandboxABI{} where every pointer is a capability.
The \sandboxABI{} is intended to evolve to a point where \creg{0} is never used.
Currently, \creg{0} is used for globals, but not for any other data accesses.

\section{Register usage}

The compiler's use of capability registers is summarized in \autoref{tbl:reguse}.
Registers \creg{16}--\creg{24} are preserved across calls, as is \creg{0}, which is never modified by the compiler.
In the \sandboxABI{}, so is \creg{11} (the stack capability).

\begin{table}
	\begin{center}
		\begin{tabu}{ll}
			\toprule
			\headerrow
			Register             & Compiler usage \\
			\midrule
			\reg{v0}             & Contains the method number for cross-domain calls.\\
			\creg{0}             & Used implicitly for all non-capability memory accesses.\\
			\creg{1}--\creg{16}  & Used for arguments in the ``fast'' calling convention. \\
			\creg{1}--\creg{2}   & Code and data capability arguments with the ``ccall'' calling convention. \\
			\creg{3}             & Capability return value. \\
			\creg{3}--\creg{10}  & Capability arguments (caller-save). \\
			\creg{11}            & Stack capability (\sandboxABI{}). \\
			\creg{12}            & Used with \asm{cjalr} as the destination register (\sandboxABI{}). \\
			\creg{13}            & Capability to on-stack arguments (variadic functions only). \\
			\creg{11}--\creg{15} & Temporary (caller-save) registers.\\
			\creg{17}            & Capability link register used with \asm{cjalr} (\sandboxABI{}).\\
			\creg{16}--\creg{24} & Saved (callee-save) registers. \\
			\creg{25}--\creg{31} & Not used by the compiler.\\
			\bottomrule
		\end{tabu}
		\caption{\label{tbl:reguse}Capability register usage.}
	\end{center}
\end{table}

\subsection{The \sandboxABI{}}

The \sandboxABI{} uses \creg{11} as a stack capability.
The \reg{sp} and \reg{fp} registers contain offsets in the stack capability.
It would make sense to replace \reg{sp} with the offset in \creg{11}.
This would simplify the addressing modes for the stack and make a lot of spills cheaper in the \sandboxABI{}.

\dcnote{Currently only true for the capcall branch, but will be merged Real Soon Nowâ„¢}
The \sandboxABI{} uses the capability mechanism to protect the return address.
In the MIPS ABI, function calls are implemented as \asm{jalr $t9, $ra}.
In the \sandboxABI{}, they are \asm{cjalr $c12, $c17}.
This has two effects.
The first is that \reg{t9} can no longer be used as a cheap way of getting the program counter for position-independent code.
Instead, if this value is needed, the compiler will emit \asm{CGetOffset $t9,$c12}, setting \reg{t9} to the \reg{pcc}-relative address of the program counter on function entry.

The second effect is that the return can be emitted as \asm{cjr $c17}.%stopzone
If \creg{17} is spilled to the stack, then it is protected by its tag bit.
If it is overwritten by anything other than an executable capability, then the \asm{cjr} instruction will trap.

\section{Calling conventions}

When targeting the n64 ABI, the only changes to the calling convention are to support capability arguments.
Capability arguments are passed in registers \creg{3} to \creg{10}, with \creg{3} also being used for capability return values.

The normal rules for composite types apply: the portions that will fit within a register are passed in registers and the remainder is passed on the stack.

\subsection{Variadic calls}

The n64 ABI requires that all arguments to variadic functions are passed either on the stack or in 8 integer registers.
When a \ccode{va_list} is constructed, the 8 integer values are written out.
This means that capability arguments in variadic functions are very difficult to support and are currently not expected to work.
To fix them, we will have to ensure that all arguments after the first capability argument are passed on the stack and that the first capability argument has a mechanism for knowing whether it is in the first 64 bytes of the \ccode{va_list} (and, if so, incrementing the pointer until it's at the end).

\index{\sandboxABI{}!variadic functions}
In the \sandboxABI{}, \textit{all} variadic arguments are passed on the stack, with their natural alignment (non-variadic arguments to variadic functions are passed in registers or on the stack as the normal calling convention would dictate).

The \reg{c13} register holds a capability to the on-stack arguments.
The \ccode{va_start} function copies the value that was stored in \reg{c13} on entry to the function.

The \ccode{va_list} is a capability to the (on-stack) variadic arguments and \ccode{va_arg} calls ensure correct alignment, load from the capability, and increment its offset past the value.
The alignment requirements can result in large gaps in the variadic argument list if integer and capability arguments are interleaved.

\begin{notebox}{General usage}
	Being able to find the range of on-stack arguments can be useful in the general case, so it may be a good idea to extend the non-variadic ABI to store the range of on-stack arguments in a capability in the same way.
	This would require that all functions that do not pass values on the stack zero \reg{c13}, but that is a relatively small overhead.
\end{notebox}

\section{Cross-domain calls: ``ccall''}

The \ir{chericcallcc} calling convention uses registers \creg{1} and \creg{2} for the first two capability arguments and \reg{v0} for the method number.
The front end will lower \ccode{struct}s that fit in registers to a sequence of scalars, so this is typically generated from a two-capability \ccode{struct}.
The remaining arguments are in the same place as the normal calling convention, allowing a simple jump to tail call functions that do not care about these arguments.

The back end tracks the argument registers that are used by callers of functions with this convention and the return registers that are used by the callee.
At each call site, it will zero unused argument registers.
In the callee, it will zero unused return registers.

\begin{notebox}{Soft float}
	The compiler currently assumes that the soft-float ABI is always used for calls into sandboxes and so does not zero any floating point registers.
	The CHERIBSD trampoline code in the kernel also makes this assumption, but it will need revisiting once floating point is enabled.
\end{notebox}

The attributes for generating this code are described in \autoref{sec:cccall}.
The compiler assumes that the runtime environment (library or kernel code) is responsible for preserving or zeroing all non-argument registers across security domain transitions.
The code to do this is the same for all functions and so having only a single instance provides better cache utilization.

The compiler generates two special sections containing metadata about cross-domain calls.
\index{\_\_cheri\_sandbox\_required\_methods section}
\asm{__cheri_sandbox_required_methods} contains metadata about methods that are required by the binary.
\index{\_\_cheri\_sandbox\_provided\_methods}
\asm{__cheri_sandbox_provided_methods} contains metadata about methods that are provided by this binary.
These are used by the \file{libcheri}\index{libcheri} runtime, to make method numbers in the caller and callee of cross-domain calls match.

For each method that is defined in the binary, the \asm{__cheri_sandbox_provided_methods} section will contain an instance of the following structure:

\begin{csnippet}
struct sandbox_provided_method
{
	int64_t   flags;
	char     *class;
	char     *method;
	void     *method_ptr;
};
\end{csnippet}

The \ccode{flags} field is currently always 0 and is reserved to permit future modifications to this structure without breaking compatibility.
The \ccode{class} field points to the name of the class for which the method is provided.
The \ccode{method} field points to the name of the method.
The \ccode{method_ptr} field is a \reg{pcc}-relative address of the method.

Similarly, for each required method the compiler will emit a structure of the following form in the \asm{__cheri_sandbox_required_methods} section:

\begin{csnippet}
struct sandbox_required_method
{
	int64_t   flags;
	char     *class;
	char     *method;
	int64_t  *method_number_var;
	int64_t   method_number;
};
\end{csnippet}

Multiple compilation units in the same binary may require the same method, so each of these structures is emitted as a single \keyword{comdat}, to allow merging.
Older versions of the cross-domain call ABI put the method numbers in a separate section and required the runtime library to walk the ELF symbol table.
The current structure is a hybrid, with the \ccode{method_number_var} field containing the address of that global, allowing code to be compiled and used with old and new versions of the runtime library.

The \ccode{flags} field is used by the runtime to indicate that a method has been resolved.
It will also be used in a future version to indicate that the \ccode{method_number_var} field has been omitted and that the generated code expects the \ccode{method_number} field to contain the authoritative version of the method number.
The top 32 bits of the \ccode{flags} field are reserved for use by the runtime, the low 32 bits for use by the compiler.

The \ccode{class} and \ccode{method} fields contain the names of the class and method, respectively.

\section{Global initialization}

\index{global initializers}
Capabilities in globals require special handling.
Capabilities can not be statically defined in the binary as other data, because doing so will not set the tag.
Similarly, existing relocation types are not sufficient to describe a capability, which has a base, bounds, and permissions in addition to the location described by conventional pointers.

\begin{notebox}{Dynamic initialization}
The initial implementation in clang simply emitted C++-style dynamic initialization code for all globals that contained non-null pointer values in the constant initializer.
This is still the default, though this will change soon and can be disabled with the \flag{-Xclang -cheri-linker} flag.
\end{notebox}

The LLVM back end will emit a special section in the ELF binary for these initializers.
This section contains one entry for each capability that must be initialized at program launch.
For example, consider the following program fragment:
\begin{csnippet}
extern int a[5];
int *b[] = {&a[2], &a[1], a};
\end{csnippet}

The resulting binary will contain a \asm{__cap_relocs}\index{\_\_cap\_relocs section} section with three instances of the following structure:

\begin{csnippet}
struct capreloc
{
	void *__capability capability_location;
	void              *object;
	uint64_t           offset;
	uint64_t           size;
	uint64_t           permissions;
};
\end{csnippet}

The \ccode{capability_location} field contains the (relative) address of the capability that must be initialised at run time.
The \ccode{object} field contains an address (and associated relocations) of the object that the capability refers to.
The \ccode{offset} field contains the offset within this object.
The \ccode{size} field contains the size of the underlying object.
The \ccode{permissions} field contains the permissions that the capability should have and reserves space for other flags.

For the above example, the compiler will emit three structures, with the following values:

\begin{csnippet}
	{ &b[0], &a, 8, 0, 0},
	{ &b[1], &a, 4, 0, 0},
	{ &b[2], &a, 0, 0, 0}
\end{csnippet}

The compiler does not know the size of the object and so will set the size to 0.
After linking, the ELF file will contain the size of the symbol.
A capability-aware linker would then fill in the size field.
In the absence of such a linker, the \tool{fixcapsize} tool will set the size.

Currently, the permissions field is always 0.
Future versions will indicate in this field whether the capability is relative to \reg{gdc} or \reg{pcc} and what permissions it should have.

You can check wither this has worked by using the \flag{-C} flag to \tool{llvm-objdump}:

\begin{verbatim}
$ llvm-objdump -C a.out

a.out:	file format ELF64-mips

CAPABILITY RELOCATION RECORDS:
0x000000000000a7a0	Base: a (0x000000000000a700)	Offset: 0000000000000008	Length: 0000000000000020
0x000000000000a7c0	Base: a (0x000000000000a700)	Offset: 0000000000000004	Length: 0000000000000020
0x000000000000a7e0	Base: a (0x000000000000a700)	Offset: 0000000000000000	Length: 0000000000000020
\end{verbatim}

There are currently some significant limitations:

\begin{itemize}
	\item We should have a flag to indicate whether this is a code (executable) or data capability, to indicate whether it should be derived from \reg{pcc} or \reg{gdc}.
	\item We have no way of enforcing permissions (for example, the \ccode{__output} or \ccode{__input} qualifier on pointers).
	\item Dynamically linked binaries will need the run-time linker to provide the symbol sizes.
\end{itemize}

\section{Return address protection}

RISC architectures typically provide a jump instruction that puts the return address in another register (e.g. \asm{jalr} on MIPS, \asm{bl[x]} on ARM).
If the called function calls another function, it must spill the return address to the stack, where it can be reloaded later.
This happens automatically on x86, where the \asm{call} and \asm{ret} instructions store the return address on the stack and read it from the stack, respectively.

If a buffer overflow allows the return address to be overwritten, then an attacker can control exactly where execution will continue after the return.

\index{CFI}\index{return address}
In the \sandboxABI{}, this kind of attack is very difficult.
Calls use the \asm{cjalr} instruction, so the return address is a \reg{pcc}-relative capability.
If this is overwritten with something that is not a capability, then the return will trigger a tag violation.
If this is overwritten by a non-executable capability, then the return will trigger a permissions violation.
For a successful exploit, the attacker would have to find an executable capability (e.g. a function pointer or a previous return address) that the program could be tricked into writing over the return address.

We would like to be able to provide the same benefits to the existing ABI.
We achieve this by keeping the call sequence the same, but modifying the return sequence.
In all non-leaf functions, when we spill the return address to the stack we also spill a \keyword{return capability}: \reg{pcc} with its offset set to the return address.
This can then be used with \asm{cjr} to return.
Note that we still spill the return address, even though it is not used, because other tools (debugging tools and so on) sometimes rely on the position of the return address on the stack.
