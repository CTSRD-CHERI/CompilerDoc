\chapter{The CHERI ABIs}
\label{chp:abis}

The CHERI compiler supports two ABIs, an extended version of the MIPS n64 ABI and the ``sandbox'' ABI where every pointer is a capability.
The sandbox ABI is intended to evolve to a point where \creg{0} is never used.
Currently, \creg{0} is used for globals, but not for any other data accesses.

\section{Register usage}

The compiler's use of capability registers is summarized in \autoref{tbl:reguse}.
Registers \creg{16}--\creg{24} are preserved across calls, as is \creg{0}, which is never modified by the compiler.
In the sandbox ABI, so is \creg{11} (the stack capability).

\begin{table}
	\begin{center}
		\begin{tabu}{ll}
			\toprule
			\headerrow
			Register             & Compiler usage \\
			\midrule
			\reg{v0}             & Contains the method number for cross-domain calls.\\
			\creg{0}             & Used implicitly for all non-capability memory accesses.\\
			\creg{1}--\creg{16}  & Used for arguments in the ``fast'' calling convention. \\
			\creg{1}--\creg{2}   & Code and data capability arguments with the ``ccall'' calling convention. \\
			\creg{3}             & Capability return value. \\
			\creg{3}--\creg{10}  & Capability arguments (caller-save). \\
			\creg{11}            & Stack capability (sandbox ABI). \\
			\creg{12}            & Used with \asm{cjalr} as the destination register (sandbox ABI). \\
			\creg{11}--\creg{15} & Temporary (caller-save) registers.\\
			\creg{17}            & Capability link register used with \asm{cjalr} (sandbox ABI).\\
			\creg{16}--\creg{24} & Saved (callee-save) registers. \\
			\creg{25}--\creg{31} & Not used by the compiler.\\
			\bottomrule
		\end{tabu}
		\caption{\label{tbl:reguse}Capability register usage.}
	\end{center}
\end{table}

\subsection{The sandbox ABI}

The sandbox ABI uses \creg{11} as a stack capability.
The \reg{sp} and \reg{fp} registers contain offsets in the stack capability.
It would make sense to replace \reg{sp} with the offset in \creg{11}.
This would simplify the addressing modes for the stack and make a lot of spills cheaper in the sandbox ABI.

\dcnote{Currently only true for the capcall branch, but will be merged Real Soon Nowâ„¢}
The sandbox ABI uses the capability mechanism to protect the return address.
In the MIPS ABI, function calls are implemented as \asm{jalr $t9, $ra}.
In the sandbox ABI, they are \asm{cjalr $c12, $c17}.
This has two effects.
The first is that \reg{t9} can no longer be used as a cheap way of getting the program counter for position-independent code.
Instead, if this value is needed, the compiler will emit \asm{CGetOffset $t9,$c12}, setting \reg{t9} to the \reg{pcc}-relative address of the program counter on function entry.

The second effect is that the return can be emitted as \asm{cjr $c17}.%stopzone
If \creg{17} is spilled to the stack, then it is protected by its tag bit.
If it is overwritten by anything other than an executable capability, then the \asm{cjr} instruction will trap.

\section{Calling conventions}

When targeting the n64 ABI, the only changes to the calling convention are to support capability arguments.
Capability arguments are passed in registers \creg{3} to \creg{10}, with \creg{3} also being used for capability return values.

The normal rules for composite types apply: the portions that will fit within a register are passed in registers and the remainder is passed on the stack.

\subsection{Variadic calls}

The n64 ABI requires that all arguments to variadic functions are passed either on the stack or in 8 integer registers.
When a \ccode{va_list} is constructed, the 8 integer values are written out.
This means that capability arguments in variadic functions are very difficult to support and are currently not expected to work.
To fix them, we will have to ensure that all arguments after the first capability argument are passed on the stack and that the first capability argument has a mechanism for knowing whether it is in the first 64 bytes of the \ccode{va_list} (and, if so, incrementing the pointer until it's at the end).

\index{sandbox ABI!variadic functions}
In the sandbox ABI, \textit{all} variadic arguments are passed on the stack, with their natural alignment (non-variadic arguments to variadic functions are passed in registers or on the stack as the normal calling convention would dictate).
The \ccode{va_list} is simply a pointer to the first (on-stack) variadic argument and \ccode{va_arg} calls simply ensure correct alignment, load from the pointer, and increment it past the value.
The alignment requirements can result in large gaps in the variadic argument list.


\section{Cross-domain calls: ``ccall''}

The \ir{chericcallcc} calling convention uses registers \creg{1} and \creg{2} for the first two capability arguments and \reg{v0} for the method number.
The front end will lower \ccode{struct}s that fit in registers to a sequence of scalars, so this is typically generated from a two-capability \ccode{struct}.
The remaining arguments are in the same place as the normal calling convention, allowing a simple jump to tail call functions that do not care about these arguments.

The back end tracks the argument registers that are used by callers of functions with this convention and the return registers that are used by the callee.
At each call site, it will zero unused argument registers.
In the callee, it will zero unused return registers.

\begin{notebox}{Soft float}
	The compiler currently assumes that the soft-float ABI is always used for calls into sandboxes and so does not zero any floating point registers.
	The CHERIBSD trampoline code in the kernel also makes this assumption, but it will need revisiting once floating point is enabled.
\end{notebox}

The code that will be generated is described in \autoref{sec:cccall}.
The compiler assumes that the runtime environment (library or kernel code) is responsible for preserving or zeroing all non-argument registers across security domain transitions.
The code to do this is the same for all functions and so having only a single instance provides better cache utilization.

\section{Global initialization}

\index{global initializers}
Capabilities in globals require special handling.
Capabilities can not be statically defined in the binary as other data, because doing so will not set the tag.
Similarly, existing relocation types are not sufficient to describe a capability, which has a base, bounds, and permissions in addition to the location described by conventional pointers.

\begin{notebox}{Dynamic initialization}
The initial implementation in clang simply emitted C++-style dynamic initialization code for all globals that contained non-null pointer values in the constant initializer.
This is still the default, though this will change soon and can be disabled with the \flag{-Xclang -cheri-linker} flag.
\end{notebox}

The LLVM back end will emit a special section in the ELF binary for these initializers.
This section contains one entry for each capability that must be initialized at program launch.
For example, consider the following program fragment:
\begin{csnippet}
extern int a[5];
int *b[] = {&a[2], &a[1], a};
\end{csnippet}

This compiles to the following assembly:

\begin{asmsnippet}
b:
$tmp0:
	.space	32
$tmp1:
	.space	32
$tmp2:
	.space	32
	.size	b, 96
	.section	__cap_relocs,"",@progbits
	.8byte	($tmp0)
	.8byte	a
	.8byte	8
	.space	16
	.8byte	($tmp1)
	.8byte	a
	.8byte	4
	.space	16
	.8byte	($tmp2)
	.8byte	a
	.space	8
	.space	16
\end{asmsnippet}

The \asm{__cap_relocs} section contains three entries, one for each capability that must be initialized (corresponding to the three elements of \ccode{b}).
The compiler emits three 64-bit entries, and leaves two blank.
These are:
\begin{enumerate}
	\item The location of the capability that must be created (i.e. \ccode{b[0]} to \ccode{b[2]}.
	\item The location of the base of the object that is the target.
	\item The offset within that object.
	\item The size of the object.
	\item The permissions that the capability should have.
\end{enumerate}

In this example, the size is not known because the object is defined in another compilation unit.
After linking, we can run the \tool{fixlinks} tool, which will inspect the size of symbols and fill in the size field.

You can check wither this has worked by using the \flag{-C} flag to \tool{llvm-objdump}:

\begin{verbatim}
$ llvm-objdump -C a.out

a.out:	file format ELF64-mips

CAPABILITY RELOCATION RECORDS:
0x000000000000a7a0	Base: a (0x000000000000a700)	Offset: 0000000000000008	Length: 0000000000000020
0x000000000000a7c0	Base: a (0x000000000000a700)	Offset: 0000000000000004	Length: 0000000000000020
0x000000000000a7e0	Base: a (0x000000000000a700)	Offset: 0000000000000000	Length: 0000000000000020
\end{verbatim}

There are currently some significant limitations:

\begin{itemize}
	\item We should have a flag to indicate whether this is a code (executable) or data capability, to indicate whether it should be derived from \reg{pcc} or \reg{gdc}.
	\item We have no way of enforcing permissions (for example, the \ccode{__output} or \ccode{__input} qualifier on pointers).
	\item Dynamically linked binaries will need the run-time linker to provide the symbol sizes.
\end{itemize}

\section{Return address protection}

RISC architectures typically provide a jump instruction that puts the return address in another register (e.g. \asm{jalr} on MIPS, \asm{bl[x]} on ARM).
If the called function calls another function, it must spill the return address to the stack, where it can be reloaded later.
This happens automatically on x86, where the \asm{call} and \asm{ret} instructions store the return address on the stack and read it from the stack, respectively.

If a buffer overflow allows the return address to be overwritten, then an attacker can control exactly where execution will continue after the return.

\index{CFI}\index{return address}
In the sandbox ABI, this kind of attack is very difficult.
Calls use the \asm{cjalr} instruction, so the return address is a \reg{pcc}-relative capability.
If this is overwritten with something that is not a capability, then the return will trigger a tag violation.
If this is overwritten by a non-executable capability, then the return will trigger a permissions violation.
For a successful exploit, the attacker would have to find an executable capability (e.g. a function pointer or a previous return address) that the program could be tricked into writing over the return address.

We would like to be able to provide the same benefits to the existing ABI.
We achieve this by keeping the call sequence the same, but modifying the return sequence.
In all non-leaf functions, when we spill the return address to the stack we also spill a \keyword{return capability}: \reg{pcc} with its offset set to the return address.
This can then be used with \asm{cjr} to return.
Note that we still spill the return address, even though it is not used, because other tools (debugging tools and so on) sometimes rely on the position of the return address on the stack.
