\chapter{C compiler support}
\label{chap:c-compiler}

The CHERI version of \keyword{Clang}, the C language front end for LLVM, has been modified to expose capabilities at the C level.

\section{Supported targets}

When targeting CHERI, you must specify a \keyword{target triple} that contains \flag{cheri} in the CPU part.  The most common triple to use is \flag{cheri-unknown-freebsd}.  This triple contains three portions, in the form \textit{cpu-vendor-os}.  The vendor is irrelevant, only the CPU and OS matter for code generation.

There are two ways to pass the triple to Clang.  The first is to add a \flag{-target} flag, followed by your triple, to your compile flags.  The second is to create a symbolic link to clang of the form \textit{cheri-unknown-freebsd-clang}.  

\begin{notebox}{\file{build\_sdk.sh}}
If you have the cross-compiler from the SDK, then it will automatically have its default target triple (and sysroot) configured correctly.  You can omit the \flag{-target} option.  You can see the default target triple by passing \flag{-v} to \file{clang}.
\end{notebox}

\section{The \sandboxABI}

\index{\sandboxABI{}}
You can select the \sandboxABI{} by passing \flag{-mabi=purecap} to clang.  When compiling in this mode, \textit{all} pointers (including function pointers) will be represented as capabilities.

The compiler will infer the size of all stack allocations automatically and expects memory allocators to set the size appropriately for their allocations.

C code in this model will not contain any non-capability load or store instructions.  This means that it is safe to clear the ambient data capability (\creg{0}) when in this mode.  It could be used as a general-purpose capability register, but is not currently.  In this mode, or one where the ambient data capability is very limited in scope, this provides full memory safety.

\section{Pointer qualifiers}

\index{pointers}\index{qualifiers}
In the compatible ABI, the \ccode{__capability} qualifier indicates that a pointer should be represented by a memory capability.
For example:

\begin{csnippet}
void *a; // 64-bit integer interpreted as a pointer
void * __capability b; // 256-bit capability interpreted as a pointer
\end{csnippet}

Implicit casts between capability and integer pointers are not permitted.
This is an intentional design decision, as such casts require careful thought to ensure that they are valid.

Clang exposes a feature-test macro that allows you to easily check whether you're compiling for a target that supports capabilities and to \ccode{#define}-way the \ccode{__capability} qualifier for other platforms:

\begin{csnippet}
	#if !__has_feature(capabilities) && !defined(__capability)
	#   define __capability
	#endif
\end{csnippet}


\section{Pragmas for generating capabilities}

\index{pointer\_interpretation pragma}
Often is it useful to define a block of code where pointers will be interpreted as either capabilities or integers, rather than having to annotate them individually.
This is possible with the \ccode{pointer_interpretation} pragma.
As with other C99 pragmas, this can be used either with the \ccode{#pragma} or \ccode{_Pragma()} syntax.

The valid options for this pragma are listed in \autoref{tbl:pointerinterpretation}.
Most uses of this pragma are likely to be via macros that explicitly push and pop.
For example, the following definitions provide a mechanism for defining ranges:

\begin{table}
	\begin{center}
		\begin{tabu}{*{2}{c}}
			\toprule
			\headerrow
			Option & Meaning\\
			\midrule
			\ccode{push} & Save the current interpretation. \\
			\ccode{pop} & Restore a previously saved interpretation. \\
			\ccode{integer} & Pointers are represented by integers. \\
			\ccode{capability} & Pointers are represented by capabilities. \\
			\ccode{default} & Pointers are represented by whatever the default is for this target. \\
			\bottomrule
		\end{tabu}
		\caption{\label{tbl:pointerinterpretation}The valid options for the pointer interpretation pragma.}
	\end{center}
\end{table}

\begin{csnippet}
#if __has_feature(pointer_interpretation)
#	define BEGIN_CAPABILITIES \
		_Pragma("pointer_interpretation push") \
		_Pragma("pointer_interpretation capability")
#	define END_CAPABILITIES \
		_Pragma("pointer_interpretation pop")
#	define BEGIN_NO_CAPABILITIES \
		_Pragma("pointer_interpretation push") \
		_Pragma("pointer_interpretation integer")
#	 END_NO_CAPABILITIES
		_Pragma("pointer_interpretation pop")
#else
#	define BEGIN_CAPABILITIES
		_Pragma("GCC error \"Compiler does not support capabilities\"")
#	define END_CAPABILITIES
		_Pragma("GCC error \"Compiler does not support capabilities\"")
#	define BEGIN_NO_CAPABILITIES
#	define END_NO_CAPABILITIES
#endif
\end{csnippet}

When compiled with a compiler that supports this pragma, they will have their expected meanings (including correctly handling nesting).
When compiled with another compiler, the \ccode{NO_CAPABILITIES} versions will be silently ignored, but the \ccode{CAPABILITIES} versions will raise an error.

This allows code like this:

\begin{csnippet}
BEGIN_CAPABILITIES
struct test
{
	int *a,*b,*c;
} t;
END_CAPABILITIES
\end{csnippet}

This is equivalent to explicitly annotating each field in the \ccode{struct} with the \ccode{__capability} annotation.


\section{Built-in functions}

The C front end provides a number of built-in functions for manipulating capabilities, listed in \autoref{tbl:builtins}.
These correspond directly to a single instruction, shown in the table.
Most of these functions (those with \ccode{memcap} in their name) are generic and should apply to any architecture that supports memory capabilities.
The remainder (those with \ccode{cheri} in their name) are specific to the current implementation.

\begin{table}
	\begin{center}
		\begin{tabu}{ll}
			\toprule
			\headerrow
			Clang builtin & CHERI instruction\\
			\midrule
			\ccode{__builtin_cheri_length_set} & \asm{CSetLen} \\
			\ccode{__builtin_cheri_length_get} & \asm{CGetLen} \\
			\ccode{__builtin_cheri_bounds_set} & \asm{CSetBounds} \\
			\ccode{__builtin_cheri_base_increment} & \asm{CIncBase} \\
			\ccode{__builtin_cheri_base_get} & \asm{CGetBase} \\
			\ccode{__builtin_cheri_perms_and} & \asm{CAndPerm} \\
			\ccode{__builtin_cheri_perms_get} & \asm{CGetPerm} \\
			\ccode{__builtin_cheri_type_get} & \asm{CGetType} \\
			\ccode{__builtin_cheri_tag_get } & \asm{CGetTag} \\
			\ccode{__builtin_cheri_sealed_get } & \asm{CGetSealed} \\
			\ccode{__builtin_cheri_tag_clear } & \asm{CClearTag} \\
			\ccode{__builtin_cheri_seal} & \asm{CSeal} \\
			\ccode{__builtin_cheri_unseal } & \asm{CUnseal} \\
			\ccode{__builtin_cheri_perms_check} & \asm{CCheckPerm} \\
			\ccode{__builtin_cheri_type_check} & \asm{CCheckType} \\
			\ccode{__builtin_cheri_offset_increment} & \asm{CIncOffset} \\
			\ccode{__builtin_cheri_offset_set} & \asm{CSetOffset} \\
			\ccode{__builtin_cheri_offset_get} & \asm{CGetOffset} \\
			\ccode{__builtin_cheri_program_counter_get} & \asm{CGetPCC} \\
			\ccode{__builtin_cheri_global_data_get} & \asm{CMove \%0, $c0} \\ %stopzone
			\ccode{__builtin_cheri_stack_get} & \asm{CMove \%0, $c11} \\ %stopzone
			\midrule
			\ccode{__builtin_mips_cheri_cause.get} & \asm{CGetCause} \\
			\ccode{__builtin_mips_cheri_cause.set} & \asm{CSetCause} \\
			\ccode{__builtin_mips_cheri_invoke_data_cap_get} & \asm{CMove \%0, $c26} \\ %stopzone
			\ccode{__builtin_mips_cheri_kernel_cap1_get} & \asm{CMove \%0, $c27} \\ %stopzone
			\ccode{__builtin_mips_cheri_kernel_cap1_get} & \asm{CMove \%0, $c28} \\ %stopzone
			\ccode{__builtin_mips_cheri_kernel_code_cap_get} & \asm{CMove \%0, $c29} \\ %stopzone
			\ccode{__builtin_mips_cheri_kernel_data_cap_get} & \asm{CMove \%0, $c30} \\ %stopzone
			\ccode{__builtin_mips_cheri_exception_program_counter_cap_get} & \asm{CMove \%0, $c31} \\ %stopzone
			\bottomrule
		\end{tabu}
		\caption{\label{tbl:builtins}C built-in functions provided for CHERI.}
	\end{center}
\end{table}



\section{Predefined macros}

CHERI Clang provides a number of feature test macros, shown in \autoref{tbl:featmacros}.
These are intended to be used to check for specific functionality and conditionally compile code.

\begin{table}
	\begin{center}
		\begin{tabu}{llp{5cm}}
			\toprule
			\headerrow
			Macro & Value & Meaning \\
			\midrule
			\ccode{_MIPS_ARCH} & \ccode{"cheri"} & The variant of the MIPS architecture in use. \\
			\ccode{_MIPS_ARCH_CHERI} & 1 & CHERI is the target (MIPS-specific). \\
			\ccode{__CHERI__} & 1 & CHERI is the target (may be used for non-MIPS implementations). \\
			\ccode{_MIPS_SZCAP} & 256 & The size of a capability (in bits). \\
			\ccode{__CHERI_PURE_CAPABILTY__} & 1 & Set only if targeting the \sandboxABI{}.\\
			\ccode{__CHERI_SANDBOX__} & 3 & Set only if targeting the \sandboxABI{}.\\
			\bottomrule
		\end{tabu}
		\caption{\label{tbl:featmacros} Feature test predefined macros supported by CHERI Clang}
	\end{center}
\end{table}

\sloppy
Additionally, the permission flags are provided as symbolic constants in the form of predefined macros.
These all start with \ccode{__CHERI_CAP_PERMISSION_} followed by a suffix from \autoref{tbl:permmacros}.
For example, \ccode{__CHERI_CAP_PERMISSION_PERMIT_SEAL__} is the permission bit for sealing.

\begin{table}
	\begin{center}
		\begin{tabu}{llp{4cm}}
			\toprule
			\headerrow
			Macro suffix & Value & Meaning \\
			\midrule
			\ccode{_GLOBAL__} & 1 & Global ``permission'' flag value. \\
			\ccode{_PERMIT_EXECUTE__} & 2 & Execute permission flag value. \\
			\ccode{_PERMIT_LOAD__} & 4 & Load (data) permission flag value. \\
			\ccode{_PERMIT_STORE__} & 8 & Store (data) permission flag value. \\
			\ccode{_PERMIT_LOAD_CAPABILITY__} & 16 & Load-capability permission flag value. \\
			\ccode{_PERMIT_STORE_CAPABILITY__} & 32 & Store-capability permission flag value. \\
			\ccode{_PERMIT_STORE_LOCAL__} & 64 & Store ephemeral permission flag value. \\
			\ccode{_PERMIT_SEAL__} & 128 & Seal permission flag value. \\
			\ccode{_ACCESS_EPCC__} & 1024 & Access \reg{epcc} permission flag value. \\
			\ccode{_ACCESS_KCC__} & 4096 & Access \reg{kcc} permission flag value. \\
			\ccode{_ACCESS_KDC__} & 2048 & Access \reg{kdc} permission flag value. \\
			\ccode{_ACCESS_KR1C__} & 8192 & Access \reg{kr1c} permission flag value.\\
			\ccode{_ACCESS_KR2C__} & 16384 & Access \reg{kr2c} permission flag value.\\
			\bottomrule
		\end{tabu}
		\caption{\label{tbl:permmacros} Suffixes of permission value predefined macros supported by CHERI Clang.  \ccode{__CHERI_CAP_PERMISSION_} is prefixed to all of these.}
	\end{center}
\end{table}

\section{\texttt{\_\_intcap\_t}}

CHERI provides two builtin types, \ccode{__intcap_t} and \ccode{__uintcap_t}.  These are expected to be \ccode{typedef}'d to \ccode{[u]intcap_t} in the compatible ABI and \ccode{[u]intptr_t} in the \sandboxABI.  These types are the same sizes as capabilities (i.e. \ccode{sizeof(__intcap_t) == sizeof(void* __capability)}).  

As with \ccode{intptr_t} in conventional C code, the goal for these types is to support any integer value or any pointer value, and to allow arbitrary arithmetic.  The C standard requires that, if \ccode{intptr_t} exists, it should be possible to store a pointer in it and recover the same pointer.  Most C code expects to be able to also perform arithmetic on the pointer value.

\index{null capability}
When an integer value is cast to an \ccode{__intcap_t}, the compiler will set that integer as the offset of a canonical null capability.  Any arithmetic on an \ccode{__intcap_t} value is performed by extracting its offset, manipulating it, and then setting it.  This ensures that integer arithmetic on \ccode{__intcap_t} values derived from integers will work precisely as expected.  Arithmetic on values derived from pointers (capabilities) is a little bit more complex.  Masking to access the unused low and high bits should still work as expected, as should addition.  Multiplication and division, however, will not.

Comparisons between \ccode{__intcap_t} values use special pointer comparison instructions.
These have the semantics that any untagged capability (including those derived from the null capability) will compare before those with a valid tag.
Within these two regions, capabilities are compared based on their absolute virtual addresses (i.e. base + offset).
Comparisons between signed and unsigned \ccode{__intcap_t} values will use the signed and unsigned variants of the compare instructions.

\begin{notebox}{Pointer comparison and garbage collection}
The C specification makes comparisons between pointers to different objects undefined.
The CHERI C compiler aims to ensure that such comparison is stable and has the same result as pointer comparison with non-capability pointers.

The fact that the CHERI model makes it possible to differentiate pointers from integers (even in the case of \ccode{__intcap_t}) means that it is possible to implement a copying garbage collector for CHERI C.
The compiler aims to ensure that virtual addresses do not leak into integer registers unless the programmer explicitly requests them to (for example, casting a capability to an \ccode{int} or explicitly accessing the base).
This means that, as long as care is taken, memory referenced by capabilities but outside of the global data capability range can be safely collected, unless the code relies on undefined behavior or explicitly attempts to subvert the garbage collector.
\end{notebox}

\section{Casts between pointers and integers}

In the hybrid ABI, most pointers are represented as integers and the cast between the two representations is purely a construct of the language type system.
In this ABI, casts between integers and \ccode{__capability}-qualified pointers are considered as being equivalent to cast between an integer-represented pointer and a capability-represented pointer.
In particular, the value of a cast should be the same independent of the intermediate integer step:
\begin{csnippet}
	void *src;
	void * __capability dest;
	void * __capability dest2;
	long mid = (long)src;
	// These are equivalent:
	dest = (void* __capability)src;
	dest2 = (void* __capability)mid;
\end{csnippet}

In the \sandboxABI, it is undefined behavior to cast from a pointer to an integer \textit{unless that pointer value was created by a cast from an integer}.
The same holds for casts between integers via \ccode{__intcap_t}.
A pointer constructed from an integer in the \sandboxABI{} is a canonical null capability with its offset set to the source integer value.
A cast from an integer to a pointer in this ABI will extract the offset.

\begin{notebox}{Other alternatives}
	It may be better for a cast from a pointer to an integer to give the absolute virtual address.
	This would involve leaking virtual addresses and prevent copying garbage collection (or, at least, break anything that expected comparisons on these pointer-derived integer values to be stable).
	This may not be an issue, as in the \sandboxABI{} it is not possible to construct a valid pointer from an integer value.
\end{notebox}

\section{Input and output}

The CHERI capability model supports pointers with restricted rights.
An early version of CHERI Clang used this to enforce \ccode{const} in hardware.
This proved problematic, for example in idioms such as \ccode{strchr}:

\begin{csnippet}
char *strchr(const char *s, int c);
\end{csnippet}

This function returns a non-\ccode{const} pointer derived from a \ccode{const} pointer.
The invariant that this intends to document is that the \ccode{strchr} function will not modify the buffer \ccode{s}.
In the capability model, it is impossible to derive a writable capability from a read-only capability, which broke any caller of this function that expected the returned pointer to be writable.

To address this, CHERI Clang provides an \ccode{__input} qualifier, which is similar to \ccode{const} but enforced in hardware.
Capabilities can be implicitly cast to \ccode{__input}-qualified versions, including as function parameters, and the compiler will insert a \asm{CAndPerms} instruction to disclaim write permissions.

A corresponding \ccode{__output} qualifier has similar behavior, creating a write-only capability.
For example, consider the following simple snippet:

\begin{csnippet}
int in(int * __input __capability x);
int out(int * __output __capability x);

void inout(int * __capability x)
{
	in(x);
	out(x);
}
\end{csnippet}

The \ccode{inout} function will compile to the following LLVM IR:

\begin{irsnippet}
; Function Attrs: nounwind
define void @inout(i32 addrspace(200)* %x) #0 {
entry:
	%0 = bitcast i32 addrspace(200)* %x to i8 addrspace(200)*
	%1 = tail call i8 addrspace(200)* @llvm.mips.cap.perms.and(i8 addrspace(200)* %0, i64 65495)
	%2 = bitcast i8 addrspace(200)* %1 to i32 addrspace(200)*
	%call = tail call i32 @in(i32 addrspace(200)* %2) #3
	%3 = tail call i8 addrspace(200)* @llvm.mips.cap.perms.and(i8 addrspace(200)* %0, i64 65515)
	%4 = bitcast i8 addrspace(200)* %3 to i32 addrspace(200)*
	%call1 = tail call i32 @out(i32 addrspace(200)* %4) #3
	ret void
}
\end{irsnippet}

The two intrinsic calls construct two capabilities derived from the original argument.
The first removes the store and store-capability permissions.
The second removes the load and load-capability permissions.
This means that the \ccode{in} function can not use its argument to write memory and the \ccode{out} function can not use its argument to read memory.

\section{Inline assembly}

Clang supports GNU-style inline assembly.
When targeting CHERI, \ccode{"C"} can be used as a register constraint indicating that a particular operand is a capability.
For example, to access the value in \creg{0}, you might write:

\begin{csnippet}
void * __capability c0;
__asm__ __volatile__ ("cmove %0, $c0"
	: "+C"(c0) /* c0 is a capability output operand */
	: /* No input operands */
	: /* No clobbers */
	);
\end{csnippet}

Note that the \ccode{+} prefix is required to indicate that this is an output register, for input operands \ccode{"C"} is correct.

\section{\file{memcap.h}}

CHERI Clang includes a header, \file{memcap.h}, which can be included by code targeting any architecture and exposes architecture-neutral definitions of types and functions for memory capabilities.

The new types and qualifiers provided by the compiler all use identifiers that start with two underscores, because this part of the namespace is reserved for the language implementation and so should not conflict with any user code.
The \file{memcap.h} header provides more human-friendly versions of these, including \ccode{intcap_t} and \ccode{uintcap_t} types, and the \ccode{capability}, \ccode{input} and \ccode{output} qualifiers.

On architectures that don't support capabilities, the two types will be equivalent to \ccode{intptr_t} and \ccode{uintptr_t} and the qualifiers will be ignored.

The header also provides versions of the \ccode{__builtin_cheri} functions, without the \ccode{__builtin_} prefix.
The versions of these that are exposed when compiling without capability support are no-ops for the set variants and define maximum permissions and bounds for the get variants.

Only the functions that are expected to be generic across all implementations of the CHERI model (as opposed to the MIPS-based concrete implementation) are exposed by this header.

\section{Compiler assistance for cross-domain calls}
\label{sec:cccall}

\index{ccall}\index{cross-domain call}
It is important to avoid leaking rights (and other information) when calling between security contexts.  CHERI implements cross-domain calls via a special instruction (\asm{ccall}) that traps to a privileged handler (currently in the kernel) to perform the domain transition.  The handler is responsible for saving and zeroing all callee-save registers and clearing all caller-save registers.  On return, the same code in the handler will restore all callee-save registers and (again) zero caller-save registers.

The handler does not know precisely what the arguments are for any function that is involved in a cross-domain call and so can not clear the unused argument registers on call, nor the unused return registers on return.

On the other side of the cross-domain call, the code must determine which method to invoke.  This is done by means of a method number, which is passed in a register that is normally unused for calls.

If a function is annotated with \ccode{__attribute__((cheri_ccall))} then the front end will replace calls to it with specially crafted calls to \ccode{cheriinvoke}, with the method number (identified by a global variable that is initialised by the sandbox loader) in the correct register.
This annotation provides two declarations of the function, one with a suffix (specified by the \ccode{cheri_method_suffix} attribute) that takes an explicit CHERI class argument and one that automatically sets the class (code and data capability) arguments from a global variable specified by the \ccode{cheri_method_class} attribute.

Functions with the \ccode{cheri_ccallee} attribute will use the ccall calling convention, and so the compiler will zero any return registers.  This is intended to allow functions to be declared that are usable both inside and between compartments.

Functions with the ccall calling convention have two extra capability argument registers, \creg{1} and \creg{2}, which contain the code and data capabilities.  
They also have an extra integer argument register (\reg{v0}), which contains the method number.  These are not exposed to functions marked as using the ccallee calling convention, which accept the normal calling convention's argument registers.  

Consider the following simple program:

\begin{csnippet}
void * __capability data;
__attribute__((cheri_ccallee))
void * __capability cgetdata(void)
{
	return data;
}

__attribute__((cheri_ccallee))
int cgetnumber(void)
{
	return 42;
}
\end{csnippet}

This contains two simple functions that are expected to be invoked as part of a domain transition.  The first returns a capability from inside its data capability, the second returns a constant.  In the first, the return value is a capability and so will be returned in capability register \creg{3}.  The two integer return registers (\reg{2} and \reg{3}, sometimes called \reg{v0} and \reg{v1}) are unused.  The compiler will generate this code for the return:

\begin{asmsnippet}
	clc     $c3, $zero, 0($c2)
	move    $2, $zero
	move    $3, $zero
\end{asmsnippet}%stopzone

The return value is loaded into \creg{3}.  The two integer return values are zeroed.  In the second function, one of the integer return registers is used, but the capability registers are not.  The compiler generates this code:

\begin{asmsnippet}
	cfromptr  $c3, $c0, $zero
	addiu     $2, $zero, 42
	move      $3, $zero
\end{asmsnippet}%stopzone

In this case, the first integer return register is set to 42, but the other return registers are cleared.  

\subsection{Cross-domain function pointers}

Cross-domain calls require more than a single capability: they require the code and data capabilities for the target, as well as the method number.
Function pointers annotated with \ccode{__attribute__((cheri_ccallback))} in the compiler will be translated to a hidden structure that contains these three components.
A call to this function pointer will be replaced by a call to \ccode{cheriinvoke} with the correct arguments set up for the cross-domain call.

Because such function pointers cannot be constructed from a simple cast, CHERI clang provides a builtin to construct them:
\begin{csnippet}
__builtin_cheri_callback_create(const char *class_name,
                                struct cheri_object object,
                                function fn);
\end{csnippet}

The final argument type is any function declared with the annotations required for exported functions.
The class name is used in combination with the function to look up the method number and the CHERI object is used directly.
This combination allows sandboxed code that is passed a function pointer of this form to call back into the specified object.
